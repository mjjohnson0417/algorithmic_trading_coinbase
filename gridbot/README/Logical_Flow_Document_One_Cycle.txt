Logical Flow Document: One Cycle of the GridManager.run Function

Overview
This document outlines the sequence of function calls executed during a single iteration of the GridManager.run function in the HBAR/USDT grid trading bot, as implemented in grid_manager.py. The run method, called every 30 seconds (default interval), orchestrates the grid trading strategy by fetching orders, checking market states, handling downtrends, resetting the grid if needed, and placing/canceling orders. The flow traces interactions with DataManager, IndicatorCalculator, OrderOperations, and StateManager, assuming all components are initialized as in hbarGridBotMainNet.py. The bot operates on Binance.US for the HBAR/USDT pair, and the flow reflects a live trading scenario unless specified.

Assumptions and Context

    Code Basis: The analysis uses the provided grid_manager.py, which does not include the five-state place_dictionary_orders, enhanced logging, or explicit prune_orders_dictionary calls in reset_grid, handle_shortterm_downtrend, handle_longterm_downtrend, or check_grid_reset_condition as described in logical_flow_grid_manager.txt. Where necessary, I will align with the original code’s logic and note differences from the referenced updated version.
    Cycle Definition: A cycle is one iteration of the while True loop in GridManager.run, executed every 30 seconds unless an error occurs.
    Initialization: The bot is fully initialized via hbarGridBotMainNet.py (API keys loaded, ExchangeConnection established, ticker and kline buffers populated, initial grid levels set). The run method’s initial setup (ticker buffer wait, grid level initialization) is complete, and self.grid_initialized = True.
    Conditions: The flow accounts for conditional branches (e.g., lttrade and sttrade flags, grid reset based on price exceeding top level).
    Logging: Logging is configured via hbarGridBotMainNet.py (RotatingFileHandler to logs/grid_bot.log). Debug logs are enabled (debug=True in GridManager), but print statements in the original code are included for console output.
    Differences from Provided Logical Flow: The original grid_manager.py lacks explicit check_grid_reset_condition, reset_grid, and five-state place_dictionary_orders. I will adapt to the original code’s structure (e.g., direct grid reset check in run, simpler order placement) and note where the updated features would apply.

Logical Flow: One Cycle of run

Function: run(interval: int = 30)
File: grid_manager.py
Purpose: Executes the main loop, coordinating grid trading operations, including order fetching, market state evaluation, downtrend handling, grid reset checks, and order placement.
Entry Point: Start of the while True loop after initial setup (ticker buffer wait and grid level initialization).
Context: The bot is running for HBAR/USDT, with self.grid_levels populated, self.grid_initialized = True, and self.orders tracking grid level states.
Actions:

    Fetches exchange orders.
    Checks long-term and short-term market states.
    Handles downtrends if detected.
    Checks for grid reset (price 30 ticks above top level).
    If trading is enabled (lttrade and sttrade True), prunes orders, updates the orders dictionary, matches to exchange, calculates order value, and places orders.
    Sleeps until the next cycle.

Step 1: Start of Cycle
Code: try: block within while True.
Actions:

    Begins a new iteration, logging the start.
    Log: self.logger.debug(f"Starting run loop iteration for {self.symbol}"). Conditions: Always executes unless an exception occurs. Next Functions Called: Proceeds to fetch exchange orders.

Step 2: Fetch Exchange Orders
Function: OrderOperations.fetch_all_orders(start_time: Optional[int] = None, end_time: Optional[int] = None)
File: order_operations.py
Purpose: Retrieves all limit orders for HBAR/USDT from the last 24 hours to sync with exchange state.
Code: self.exchange_orders = self.order_operations.fetch_all_orders(start_time=start_time_ms) (where start_time_ms is 24 hours ago).
Actions:

    Queries Binance.US via CCXT’s fetch_orders, passing symbol='HBAR/USDT', since=start_time_ms, and optional endTime params.
    Formats orders into a list of dictionaries with keys id, type (limit_buy or limit_sell), price, quantity, symbol, status.
    Filters to limit orders only (ignores market orders).
    Logs the number of orders fetched if self.debug=True (e.g., logging.debug(f"Fetched {len(formatted_orders)} orders for {self.symbol} from {start_str} to {end_str}")).
    Handles errors (authentication, network, exchange) by logging and returning an empty list. Returns: List of order dictionaries (e.g., [{'id': '123', 'type': 'limit_buy', 'price': 0.1, 'quantity': 100, 'symbol': 'HBAR/USDT', 'status': 'open'}]) or [] on error. Dependencies: CCXT’s fetch_orders via ExchangeConnection.rest_exchange. Outcome: Populates self.exchange_orders with current order data for synchronization. Log: Info log on success (e.g., logging.debug(f"Fetched {len(formatted_orders)} orders ...")), error log on failure (e.g., logging.error(f"Authentication error fetching all orders ...")). Next Functions Called: Proceeds to check market states.

Step 3: Check Market States
Function: None (direct code in run)
Purpose: Evaluates long-term (1d) and short-term (1h) market states to set self.lttrade and self.sttrade flags, triggering downtrend handling if needed.
Code:
python
long_term_state = self.state_manager.get_market_state(self.symbol, timeframe='1d')
self.lttrade = long_term_state in ['uptrend', 'sideways']
short_term_state = self.state_manager.get_market_state(self.symbol, timeframe='1h')
self.sttrade = short_term_state in ['uptrend', 'sideways']

Actions:

    Calls StateManager.get_market_state for 1d and 1h timeframes.
    Sets self.lttrade and self.sttrade based on market states.
    Logs states (e.g., self.logger.debug(f"Long-term state: {long_term_state}, lttrade: {self.lttrade}")). Sub-Functions Called:
    StateManager.get_market_state(symbol: str, timeframe: str = '1d') File: state_manager.py Purpose: Determines market state ('uptrend', 'downtrend', 'sideways', or None) based on technical indicators. Actions:
        Checks timeframe ('1d' or '1h').
        Fetches kline buffer from DataManager.
        Computes indicators via IndicatorCalculator.
        Evaluates state using EMA12, EMA26, RSI14, ADX14. Sub-Functions Called:
        DataManager.get_buffer(buffer_type: str) File: data_manager.py Purpose: Retrieves kline buffer (klines_1d for 1d, klines_1h for 1h). Actions: Returns pandas DataFrame with columns [timestamp, open, high, low, close, volume] or empty DataFrame if not populated. Returns: DataFrame. Notes: Assumes buffers are preloaded by hbarGridBotMainNet.py (preload_1d_klines, preload_1h_klines).
        IndicatorCalculator.calculate_1d_indicators(klines_1d: pd.DataFrame, symbol: str) (for 1d) File: indicator_calculator.py Purpose: Computes indicators (EMA12, EMA26, RSI14, ADX14, ATR14, MACD) from 1-day klines. Actions:
            Validates kline data (26+ rows, required columns, no NaN).
            Calculates indicators using internal methods.
            Logs details if self.debug=True (e.g., logging.debug(f"1-day indicators for {symbol}: {indicators}")).
            Prints warnings for invalid data (e.g., print(f"WARNING: Empty 1-day klines buffer for {symbol}.")). Sub-Functions Called:
            IndicatorCalculator._calculate_rsi(prices: pd.Series, period: int) Purpose: Calculates RSI14 for close prices. Actions: Computes gains/losses, averages over 14 periods. Returns: Float (e.g., 50.0) or 50.0 if insufficient data.
            IndicatorCalculator._calculate_adx(klines: pd.DataFrame, period: int) Purpose: Calculates ADX14 for trend strength. Actions: Computes true range, directional movement, ADX over 14 periods. Returns: Float (e.g., 25.0) or 0.0 if insufficient data.
            IndicatorCalculator._calculate_atr(klines: pd.DataFrame, period: int) Purpose: Calculates ATR14 for volatility. Actions: Computes true range, averages over 14 periods. Returns: Float (e.g., 0.002) or 0.0001 if insufficient data.
            IndicatorCalculator._calculate_macd(prices: pd.Series) Purpose: Calculates MACD (macd, macd_signal, macd_hist). Actions: Computes EMA12, EMA26, signal line over 9 periods. Returns: Tuple of floats (e.g., (0.001, 0.0005, 0.0005)) or (0.0, 0.0, 0.0) if insufficient data. Returns: Dictionary of indicators (e.g., {'ema12': 0.105, 'ema26': 0.104, 'rsi14': 50.0, 'adx14': 25.0, ...}) or {} if invalid data.
        IndicatorCalculator.calculate_1h_indicators(klines_1h: pd.DataFrame, symbol: str) (for 1h) Purpose: Same as calculate_1d_indicators but for 1-hour klines. Actions: Identical validation and calculation logic. Returns: Same format as 1d indicators. Sub-Functions Called: Same as above (_calculate_rsi, _calculate_adx, _calculate_atr, _calculate_macd). Logic in get_market_state:
        IF indicators empty: Return None.
        IF ADX14 < 20: Return 'sideways'.
        IF EMA12 > EMA26 and RSI14 < 70 and ADX14 >= 20: Return 'uptrend'.
        IF EMA12 < EMA26 and RSI14 > 30 and ADX14 >= 20: Return 'downtrend'.
        ELSE: Return 'sideways'. Returns: 'uptrend', 'downtrend', 'sideways', or None. Outcome: Provides market state for setting lttrade and sttrade. Log: Debug logs for states (e.g., logging.debug(f"Market states for {self.symbol}: long_term={long_term_state}, ...")).

Conditions:

    Always called to assess market conditions.
    self.lttrade = True if long_term_state is 'uptrend' or 'sideways', else False.
    self.sttrade = True if short_term_state is 'uptrend' or 'sideways', else False. Outcome: Updates self.lttrade and self.sttrade, determining whether trading proceeds or downtrend handling is triggered. Log: Logs market states and flag updates (e.g., self.logger.info(f"Long-term trading {'enabled' if self.lttrade else 'disabled'} ...")). Next Functions Called: Proceeds to handle downtrends or trading logic based on lttrade and sttrade.

Step 4: Handle Long-Term Downtrend (if self.lttrade == False)
Function: None (direct code in run)
Purpose: Manages long-term downtrend by canceling all orders and selling all HBAR assets.
Code:
python
if not self.lttrade:
    self.logger.info(f"Long-term downtrend detected for {self.symbol}, cancelling all orders and selling assets")
    self.order_operations.cancel_all_buy_orders()
    self.order_operations.cancel_all_sell_orders()
    self.order_operations.sell_all_assets()
    self.orders = {}
    self.grid_initialized = False

Actions:

    Logs downtrend detection.
    Clears self.orders dictionary.
    Sets self.grid_initialized = False to pause trading. Sub-Functions Called:
    OrderOperations.cancel_all_buy_orders() File: order_operations.py Purpose: Cancels all limit and market buy orders. Actions:
        Iterates self.active_orders, cancels buy orders via CCXT’s cancel_order.
        Removes canceled orders from self.active_orders.
        Logs cancellations if self.debug=True (e.g., logging.debug(f"Cancelled buy order: {order_id}")).
        In dry_run mode, simulates cancellation by removing from self.active_orders. Returns: None.
    OrderOperations.cancel_all_sell_orders() File: order_operations.py Purpose: Cancels all limit and market sell orders. Actions: Similar to cancel_all_buy_orders. Returns: None.
    OrderOperations.sell_all_assets() File: order_operations.py Purpose: Sells all HBAR balance at market price. Actions:
        Extracts base asset ('HBAR' from 'HBAR/USDT').
        Calls get_base_asset_balance to check HBAR balance.
        If balance > 0, calls create_market_sell to sell.
        Logs success or failure (e.g., logging.info(f"Placed market sell order for {balance} {base_asset}")). Sub-Functions Called:
        OrderOperations.get_base_asset_balance(base_asset: str) Purpose: Retrieves free HBAR balance. Actions: Queries Binance.US via CCXT’s fetch_balance, extracts HBAR free balance. Returns: Float (e.g., 100.0) or 0.0 on error. Log: Debug log if self.debug=True (e.g., logging.debug(f"Fetched {base_asset} balance: {asset_balance}")).
        OrderOperations.create_market_sell(quantity: float) Purpose: Places market sell order for specified quantity. Actions:
            Calls CCXT’s create_market_sell_order.
            Adds order to self.active_orders.
            Logs order details if self.debug=True.
            In dry_run mode, simulates with mock ID (e.g., dry_run_market_sell_{quantity}). Returns: Order ID (string) or None if failed. Returns: None. Conditions: Executed if self.lttrade == False (long_term_state is 'downtrend' or None). Outcome: Cancels all orders, sells HBAR assets, clears self.orders, and pauses trading. Log: Info log for actions (e.g., self.logger.info(f"Long-term downtrend detected ...")). Next Functions Called: Skips to sleep (Step 8), as trading is disabled.

Step 5: Handle Short-Term Downtrend (if self.lttrade and not self.sttrade)
Function: None (direct code in run)
Purpose: Manages short-term downtrend by canceling buy orders.
Code:
python
elif self.lttrade and not self.sttrade:
    self.logger.info(f"Short-term downtrend detected for {self.symbol}, cancelling buy orders")
    self.order_operations.cancel_all_buy_orders()

Actions:

    Logs short-term downtrend detection.
    Cancels buy orders to pause buying activity. Sub-Functions Called:
    OrderOperations.cancel_all_buy_orders() Purpose: As described in Step 4. Actions: Cancels all buy orders, updates self.active_orders. Returns: None. Conditions: Executed if self.lttrade == True and self.sttrade == False (short_term_state is 'downtrend' or None). Outcome: Cancels buy orders, allowing sell orders to remain active. Log: Info log for action (e.g., self.logger.info(f"Short-term downtrend detected ...")). Next Functions Called: Skips to sleep (Step 8), as trading is partially disabled.

Step 6: Check Grid Reset Condition
Function: None (direct code in run)
Purpose: Checks if the last 30 ticker prices exceed the top grid level, recalculating grid levels if true.
Code:
python
ticker_df = self.data_manager.get_buffer('ticker')
if not ticker_df.empty and len(ticker_df) >= 30:
    last_30_prices = ticker_df['last_price'].tail(30)
    if (last_30_prices > max(self.grid_levels)).all():
        self.logger.info(f"Resetting grid for {self.symbol}: last 30 prices above top grid level")
        self.grid_levels = self.calculate_grid_levels()
        self.grid_initialized = True

Actions:

    Fetches ticker buffer to check recent prices.
    Validates buffer (not empty, 30+ rows).
    Checks if all last 30 prices exceed max(self.grid_levels).
    If true, logs reset and recalculates grid levels. Sub-Functions Called:
    DataManager.get_buffer(buffer_type: str) Purpose: Retrieves ticker buffer. Actions: Returns DataFrame with last_price column or empty DataFrame. Returns: DataFrame.
    GridManager.calculate_grid_levels() File: grid_manager.py Purpose: Generates 20 grid levels based on ATR and current price. Actions:
        Fetches current price from ticker buffer.
        If invalid, logs error and returns [].
        Fetches 1-hour klines for ATR calculation.
        Computes ATR via IndicatorCalculator.
        Sets grid spacing as atr * 2.0, with minimum spacing (0.2% + 1% of price).
        Generates 10 levels above and below current price, offset by half spacing.
        Sorts and formats levels to 5 decimal places.
        Logs new levels (e.g., self.logger.info(f"Calculated {len(self.grid_levels)} grid levels ...")). Sub-Functions Called:
        DataManager.get_buffer(buffer_type: str) Purpose: Retrieves klines_1h buffer. Actions: Returns DataFrame with close prices. Returns: DataFrame.
        IndicatorCalculator.calculate_1h_indicators(klines_1h: pd.DataFrame, symbol: str) Purpose: Computes ATR14 for grid spacing. Actions: Validates klines, calculates indicators. Returns: Dictionary with atr14 (e.g., {'atr14': 0.002, ...}) or {} if invalid. Sub-Functions Called:
            IndicatorCalculator._calculate_atr(klines: pd.DataFrame, period: int) Purpose: Computes ATR14 for volatility-based spacing. Actions: Calculates true range, averages over 14 periods. Returns: Float (e.g., 0.002) or 0.0001 if invalid. Returns: List of 20 price levels (e.g., [0.095, 0.0975, ..., 0.105]) or [] if invalid data. Conditions:
    Executed if ticker buffer has 30+ rows and all last 30 prices exceed top grid level.
    Skips reset if condition is not met or data is invalid. Outcome: Updates self.grid_levels with new levels if reset is triggered, sets self.grid_initialized = True. Log: Info log for reset (e.g., self.logger.info(f"Resetting grid for {self.symbol} ...")). Notes: Unlike the updated version’s check_grid_reset_condition and reset_grid (which cancel buy orders and prune the dictionary), the original code only recalculates levels. Next Functions Called: Proceeds to trading logic if self.lttrade and self.sttrade are True; otherwise, skips to sleep.

Step 7: Trading Logic (if self.lttrade and self.sttrade)
Function: None (direct code in run)
Purpose: Executes grid trading operations when both long-term and short-term market conditions allow, including pruning orders, updating the orders dictionary, syncing with exchange, calculating order value, and placing orders.
Code:
python
if self.lttrade and self.sttrade:
    self.prune_inactive_orders(self.exchange_orders)
    self.update_orders_dict()
    self.match_orders_dict_to_exchange()
    order_value = self.calculate_order_value()
    self.place_orders(order_value)

Actions:

    Performs full trading cycle if trading is enabled.
    Logs trading start (e.g., self.logger.debug(f"Executing trading logic for {self.symbol}")). Sub-Functions Called:
    GridManager.prune_inactive_orders(exchange_orders: list) Purpose: Removes inactive orders from self.orders to maintain valid state. Actions:
        Compares self.orders with exchange_orders.
        Removes entries where buy_id or sell_id do not match active exchange orders.
        Logs pruning actions (e.g., self.logger.debug(f"Pruned inactive order at level {level}")). Returns: None. Outcome: Ensures self.orders reflects active exchange orders. Notes: In the updated version, this would align with prune_orders_dictionary, which also considers active grid ranges and bot state.
    GridManager.update_orders_dict() Purpose: Updates self.orders to maintain 5 buy levels below and 1 sell level above current price. Actions:
        Fetches current price from ticker buffer.
        Identifies grid levels: 5 below current price for buys, 1 above for sells.
        Adds levels to self.orders if missing, initializing states (buy_id, sell_id, buy_locked, buy_state, sell_state).
        Ensures buy-first dependency (sell orders placed only after buy fills).
        Logs updates (e.g., self.logger.debug(f"Added level {level} to orders dictionary")). Sub-Functions Called:
        DataManager.get_buffer(buffer_type: str) Purpose: Retrieves ticker buffer for current price. Actions: Returns DataFrame with last_price. Returns: DataFrame or empty DataFrame. Returns: None. Outcome: Populates self.orders with desired grid levels.
    GridManager.match_orders_dict_to_exchange() Purpose: Synchronizes self.orders with exchange orders, canceling stray orders not at desired grid levels. Actions:
        Compares self.orders with self.exchange_orders.
        Updates order states (buy_state, sell_state) based on exchange order status.
        Cancels stray exchange orders not in self.orders using OrderOperations.cancel_order.
        Logs actions (e.g., self.logger.info(f"Canceled stray order ID {order_id} at {price}")). Sub-Functions Called:
        OrderOperations.cancel_order(order_id: str) File: order_operations.py Purpose: Cancels a specific order by ID. Actions:
            Calls CCXT’s cancel_order if order_id is in self.active_orders.
            Removes from self.active_orders.
            Logs cancellation if self.debug=True (e.g., logging.debug(f"Cancelled order: {order_id}")).
            In dry_run mode, simulates by removing from self.active_orders. Returns: None. Returns: None. Outcome: Aligns self.orders with exchange state, removing stray orders.
    GridManager.calculate_order_value() Purpose: Calculates order size based on USDT balance and open orders value. Actions:
        Fetches open orders via OrderOperations.fetch_open_orders.
        Calculates total value of open orders for HBAR/USDT.
        Fetches USDT balance via OrderOperations.get_usdt_balance.
        Computes order value as (0.75 * (open_orders_value + usdt_balance)) / len(self.grid_levels).
        Logs result (e.g., self.logger.info(f"Calculated order value: {order_value}")). Sub-Functions Called:
        OrderOperations.fetch_open_orders() File: order_operations.py Purpose: Retrieves currently open orders for HBAR/USDT. Actions:
            Queries Binance.US via CCXT’s fetch_open_orders.
            Formats orders into list of dictionaries (similar to fetch_all_orders).
            Logs orders if self.debug=True (e.g., logging.debug(f"Fetched {len(formatted_orders)} open orders ...")).
            Returns empty list on errors. Returns: List of order dictionaries (e.g., [{'id': '123', 'type': 'limit_buy', ...}]).
        OrderOperations.get_usdt_balance() File: order_operations.py Purpose: Retrieves free USDT balance. Actions:
            Queries Binance.US via CCXT’s fetch_balance.
            Extracts USDT free balance.
            Logs balance if self.debug=True (e.g., logging.debug(f"Fetched USDT balance: {usdt_balance}")).
            Returns 0.0 on error. Returns: Float (e.g., 500.0) or 0.0. Returns: Float (e.g., 10.0 USDT per order) or 0.0 if invalid. Outcome: Provides order_value for order placement.
    GridManager.place_orders(order_value: float) Purpose: Places buy/sell orders at grid levels based on self.orders states. Actions:
        Iterates self.grid_levels.
        For each level, checks self.orders[level] state.
        Places buy orders at levels below current price if no active buy order (buy_id is None, buy_locked is False).
        Places sell orders at levels above current price if buy order is filled (buy_state is 'closed').
        Updates self.orders with order IDs and states.
        Logs placements (e.g., self.logger.info(f"Placed buy order at {level}: ID={order_id}, quantity={quantity}")). Sub-Functions Called:
        OrderOperations.create_limit_buy(price: float, quantity: float) File: order_operations.py Purpose: Places a limit buy order at specified price and quantity. Actions:
            Calls CCXT’s create_limit_buy_order.
            Adds order to self.active_orders with details (type, price, quantity, symbol, status).
            Logs order if self.debug=True (e.g., logging.debug(f"Created limit buy order: {order}")).
            In dry_run mode, simulates with mock ID (e.g., dry_run_buy_{price}_{quantity}). Returns: Order ID (string) or None if failed.
        OrderOperations.create_limit_sell(price: float, quantity: float) Purpose: Places a limit sell order. Actions: Similar to create_limit_buy. Returns: Order ID or None. Returns: None. Outcome: Places orders at grid levels, updates self.orders. Notes: The original code uses a simpler state model (not five-state as in logical_flow_grid_manager.txt). Buy orders are placed if buy_locked=False, and sell orders require a filled buy order.

Conditions:

    Executed only if self.lttrade and self.sttrade are True.
    Skips if either flag is False (after downtrend handling). Outcome: Updates self.orders, places new orders, and syncs with exchange. Log: Logs trading actions (e.g., self.logger.info(f"Trading enabled, processing orders for {self.symbol}")). Next Functions Called: Proceeds to sleep (Step 8).

Step 8: Sleep and End of Cycle
Function: None (uses asyncio.sleep)
Purpose: Pauses execution until the next cycle to maintain the 30-second interval.
Code: await asyncio.sleep(self.interval)
Actions:

    Sleeps for self.interval seconds (default 30).
    Logs sleep action (e.g., self.logger.debug(f"Sleeping for {self.interval} seconds")). Conditions: Always executed unless an exception occurs earlier. Outcome: Completes the cycle, returning to Step 1 for the next iteration. Log: Debug log for sleep (e.g., self.logger.debug(f"Sleeping for 30 seconds ...")). Next Functions Called: Returns to Step 1 unless an exception triggers error handling.

Error Handling
Context: The entire cycle is wrapped in a try-except block.
Code:
python
except Exception as e:
    self.logger.error(f"Error in run loop for {self.symbol}: {e}", exc_info=True)
    await asyncio.sleep(5)
    continue

Actions:

    Logs the error with stack trace (e.g., self.logger.error(f"Error in run loop ...")).
    Sleeps for 5 seconds to prevent rapid error looping.
    Continues to the next cycle. Functions Called: None (only asyncio.sleep). Outcome: Ensures the bot continues running despite errors, logging issues for troubleshooting.

Summary of Function Call Order
The following lists all functions called in a typical cycle, assuming:

    Trading is enabled (self.lttrade and self.sttrade are True).
    No grid reset is triggered (alternative path noted).
    No errors occur (error handling is separate).

    GridManager.run() (entry point, start of while True loop).
    OrderOperations.fetch_all_orders() (fetches exchange orders).
    StateManager.get_market_state(timeframe='1d'):
        DataManager.get_buffer('klines_1d')
        IndicatorCalculator.calculate_1d_indicators()
            IndicatorCalculator._calculate_rsi()
            IndicatorCalculator._calculate_adx()
            IndicatorCalculator._calculate_atr()
            IndicatorCalculator._calculate_macd()
    StateManager.get_market_state(timeframe='1h'):
        DataManager.get_buffer('klines_1h')
        IndicatorCalculator.calculate_1h_indicators()
            Same sub-functions as above.
    (If self.lttrade == False):
        OrderOperations.cancel_all_buy_orders()
        OrderOperations.cancel_all_sell_orders()
        OrderOperations.sell_all_assets()
            OrderOperations.get_base_asset_balance()
            OrderOperations.create_market_sell()
    (Else if self.lttrade and not self.sttrade):
        OrderOperations.cancel_all_buy_orders()
    (Else if grid reset condition met):
        DataManager.get_buffer('ticker')
        GridManager.calculate_grid_levels()
            DataManager.get_buffer('klines_1h')
            IndicatorCalculator.calculate_1h_indicators()
                IndicatorCalculator._calculate_atr()
    (If self.lttrade and self.sttrade):
        GridManager.prune_inactive_orders()
        GridManager.update_orders_dict()
            DataManager.get_buffer('ticker')
        GridManager.match_orders_dict_to_exchange()
            OrderOperations.cancel_order()
        GridManager.calculate_order_value()
            OrderOperations.fetch_open_orders()
            OrderOperations.get_usdt_balance()
        GridManager.place_orders()
            OrderOperations.create_limit_buy()
            OrderOperations.create_limit_sell()
    (Direct code: asyncio.sleep(interval) to pause).

Alternative Paths

    Long-Term Downtrend (<code>self.lttrade == False</code>):
        Executes Step 4: cancel_all_buy_orders, cancel_all_sell_orders, sell_all_assets (with get_base_asset_balance, create_market_sell).
        Clears self.orders, sets self.grid_initialized = False, skips to Step 8.
    Short-Term Downtrend (<code>self.lttrade</code> and not <code>self.sttrade</code>):
        Executes Step 5: cancel_all_buy_orders.
        Skips to Step 8.
    Grid Reset (30 ticks above top level):
        Executes Step 6: calculate_grid_levels (with get_buffer, calculate_1h_indicators, _calculate_atr).
        Updates self.grid_levels, proceeds to Step 7 if trading enabled.
    Error Cases:
        Empty/invalid ticker buffer → Skips to Step 8.
        Exception in any step → Logs error, sleeps 5 seconds, restarts cycle.

Visual Flow (Simplified)
text
run
├── OrderOperations.fetch_all_orders
├── StateManager.get_market_state (1d)
│   ├── DataManager.get_buffer (klines_1d)
│   └── IndicatorCalculator.calculate_1d_indicators
│       ├── _calculate_rsi
│       ├── _calculate_adx
│       ├── _calculate_atr
│       └── _calculate_macd
├── StateManager.get_market_state (1h)
│   ├── DataManager.get_buffer (klines_1h)
│   └── IndicatorCalculator.calculate_1h_indicators
│       ├── _calculate_rsi
│       ├── _calculate_adx
│       ├── _calculate_atr
│       └── _calculate_macd
├── [IF not lttrade: Long-term downtrend]
│   ├── OrderOperations.cancel_all_buy_orders
│   ├── OrderOperations.cancel_all_sell_orders
│   └── OrderOperations.sell_all_assets
│       ├── get_base_asset_balance
│       └── create_market_sell
├── [ELIF lttrade and not sttrade: Short-term downtrend]
│   └── OrderOperations.cancel_all_buy_orders
├── [IF grid reset condition met]
│   ├── DataManager.get_buffer (ticker)
│   └── GridManager.calculate_grid_levels
│       ├── DataManager.get_buffer (klines_1h)
│       └── IndicatorCalculator.calculate_1h_indicators
│           └── _calculate_atr
├── [IF lttrade and sttrade]
│   ├── GridManager.prune_inactive_orders
│   ├── GridManager.update_orders_dict
│   │   └── DataManager.get_buffer (ticker)
│   ├── GridManager.match_orders_dict_to_exchange
│   │   └── OrderOperations.cancel_order
│   ├── GridManager.calculate_order_value
│   │   ├── OrderOperations.fetch_open_orders
│   │   └── OrderOperations.get_usdt_balance
│   └── GridManager.place_orders
│       ├── OrderOperations.create_limit_buy
│       └── OrderOperations.create_limit_sell
└── (Sleep for interval)

Notes

    Cycle Duration: Approximately 30 seconds (default interval) plus execution time, unless errors trigger a 5-second sleep.
    External Dependencies: Relies on DataManager, IndicatorCalculator, OrderOperations, and StateManager methods, assumed to function as implemented.
    Troubleshooting: Debug logs in logs/grid_bot.log trace each step (e.g., order IDs, market states, grid levels). Enable debug=True in all components for maximum detail.
    Differences from Provided Logical Flow:
        The original grid_manager.py lacks check_grid_reset_condition, reset_grid, and five-state place_dictionary_orders. Grid reset is handled directly in run, and order placement uses a simpler state model.
        No explicit prune_orders_dictionary calls in downtrend handlers or reset; self.orders is cleared directly in long-term downtrend.
        Logging is less comprehensive (fewer self.logger.info statements), and some print statements remain.
        To align with the provided flow, reset_grid would include order cancellation and pruning, and place_dictionary_orders would use a five-state model.
    Conditional Execution: The flow varies based on market states and grid reset conditions. The above covers the typical trading-enabled case.
    Initialization Context: ExchangeConnection and KeyLoader are used during setup (hbarGridBotMainNet.py) but not in the run cycle. GracefulShutdown handles termination, not part of the cycle.

Created: May 11, 2025

